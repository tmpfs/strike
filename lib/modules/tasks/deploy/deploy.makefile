# generate the makefile
makefile() {
	local makefile="${bundle_source}/${names[makefile]}";
	
	# using a custom make file
	if [ -n "${sources[make]}" ]; then
		cp "${sources[make]}" "${makefile}" \
			|| :tasks.deploy.fail "could not copy make file %s" \
				"${sources[make]}";
		return 0;
	fi
	
	declare -A make_targets;
	declare -A make_rules;
	
	local bundle_makefile="";
	local bundle_makefile_name="";
	local bundle_makefile_relative="";
	makefile.exists?;
	local has_makefile=$?;
	local has_makefile_install_target=1;
	
	# write make file header
	makefile.header;	
	
	# not a standalone bundle or no makefile bundled
	# so always proxy to the installation script
	if ! ${flags[bundle.standalone]} || [ $has_makefile -gt 0 ]; then
		makefile.script.proxy;
		makefile.targets;
	# standalone and a makefile is bundled
	# so let's see whether we proxy
	elif [ $has_makefile -eq 0 ]; then
			# make -qp | grep -v '^# ' | grep -v '^[[:space:]]' | grep --only-matching '^.*:' | grep 'install:';
		
			# echo "got custom makefile: $bundle_makefile"
			
			# determine if the makefile has a install target
			# executed in a subshell so the working directory
			# is not affected
			# (
			# 	cd "${bundle_contents_path}" \
			# 		&& make -qp \
			# 		| grep -v '^# ' \
			# 		| grep -v '^[[:space:]]' \
			# 		| grep --only-matching '^.*:' \
			# 		| grep 'install:' > /dev/null 2>&1
			# )
			# has_makefile_install_target=$?;
			# # no install target in bundled makefile
			# # so we can proxy the install target to
			# # the script and all other targets to the
			# # bundled makefile using an include
			# if [ $has_makefile_install_target -gt 0 ]; then
			# 	# NOTE: the script proxy is done first so
			# 	# NOTE: it becomes the default target and can
			# 	# NOTE: be executed with just `make`
			# 	makefile.script.proxy;
			# 	makefile.targets;
			# 	makefile.proxy "${names[bundle.contents]}" "$bundle_makefile_name";
			# # the bundled makefile has an install target
			# # so we just proxy everything
			# else
			# 	makefile.proxy "${names[bundle.contents]}" "$bundle_makefile_name";				
			# fi
			
	
			# if the has make file was set by detecting a
			# configure.ac file then bundle make file will
			# be empty to assume the default name
			if [ -z "${bundle_makefile_name:-}" ]; then
				bundle_makefile_name="${names[makefile]}";
			fi
			
			makefile.proxy "${names[bundle.contents]}" "${bundle_makefile_name}";
	fi
	
	makefile.phony;
	
	# cat "$makefile";
}

# determine if a makefile name is recognised
makefile.name.valid?() {
	local name="${1:-}";
	local word;
	for word in ${names[makefiles]}
		do
			if [ "$name" == "$word" ]; then
				return 0;
			fi
	done
	return 1;
}

# sets the makefile targets and rules to
# proxy to the installation script
makefile.script.proxy() {
	# add an empty all target and
	# create an install target that executes
	# the bundled install script
	make_targets[targets]="all install";
	make_rules[install]="./${names[script]} \$@";
}

# write an include directive to the makefile
makefile.proxy() {
cat <<EOF >> "${makefile}"
all:
	@\$(MAKE) --directory $1 --file $2 \$@

%: force
	@\$(MAKE) --directory $1 --file $2 \$@

force:
	@echo > /dev/null

.PHONY: all force
.SILENT: all force

EOF
}

# determine if the package contents has a makefile
makefile.exists?() {
	# FIXME: if the bundle is created on a case-insensitive
	# FIXME: platform but deployed to a case-sensitive platform
	# FIXME: the make file name will be incorrect in deployment
	
	# if a bundle contents contains a configure.ac
	# file then we should always proxy
	if [ -f "${bundle_contents_path}/${names[autoconf.ac]}" ]; then
		return 0;
	fi
	
	local name;
	for name in ${names[makefiles]}
		do
			if [ -f "${bundle_contents_path}/${name}" ]; then
				bundle_makefile="${bundle_contents_path}/${name}";
				bundle_makefile_name="${name}";
				bundle_makefile_relative="${bundle_makefile#$bundle_source/}";
				return 0;
			fi
	done
	return 1;
}

makefile.header() {
cat <<EOF >> "${makefile}"
# generated by task-deploy(7)
# do not edit this file manually
# use bake(1) with task-deploy(7)

EOF
}

makefile.targets() {
	local word rule rules;
	for word in ${make_targets[targets]}
		do
			printf "${word}:\n" >> "${makefile}";
			rules="${make_rules[$word]:-}";
			if [ -n "$rules" ]; then
				# echo "got rules : $rules";
				local IFS=$'\n';
				rules=( ${rules} );
				unset IFS;
				for rule in "${rules[@]}"
					do
 						printf "\t${rule}" >> "${makefile}";
				done
			fi
	done
}

makefile.phony() {
	if [ -n "${make_targets[targets]:-}" ]; then
		printf "\n.PHONY: ${make_targets[targets]}" >> "${makefile}";
	fi
}