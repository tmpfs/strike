: <<'ronn:markdown'
task-todo(7) -- todo task(s) for bake(1)
=============================================

## SYNOPSIS

Task(s) for bake(1) to find *TODO* tags in a project.

## DESCRIPTION

Adds task methods for scanning a project looking for *TODO* tags, use these commands to give your code a sanity check.

## REQUIRE

In your tasks(7) file `require` the `todo` task(s) using:

	require 'tasks/todo';

## USAGE

	bake todo [commands...] [flags...]
	
## COMMANDS

This section describes the command options for task-todo(7). When no command is specified the default behaviour is to call the `scan` command.

* `scan`:

Scan the project `${root}` for files and print *TODO* tags information.
	
The format of the output for each tag found is a comment line (preceeded by a '#' character and a single space) with the tag converted to uppercase followed by a space and then the file path concatenated with the line number using a ':' delimiter, for example:

	# TODO /path/to/project/bin/bake:358
	this is a todo message
	
Output for *BUG* and *FIXME* tags found is redirected to stderr, all other tags found are sent to stdout. This enables easy redirection of these tags to a file using a command such as:

	bake todo scan 2> target/todo.err.log

* `tags`:

The `tags` command prints a list of tag identifiers and the corresponding pattern used to match a tag.
	
The output format for this command is an uppercase tag identifier delimited by the equals sign '=' followed by the pattern used to match the tag.

* `list`:

Use the `list` command to print a list of the files that a scan would match.

* `count`:

Count occurences of tags, this implies the `--silent` option. The format of count output is an uppercase tag name and the count value delimited by an '=' character, for example:

	TODO=76
	
* `excludes`:

Prints the exclude patterns.

## OPTIONS

Options for task-todo(7).

* `--dir`:

Add one or more directories *relative to the project root* to scan for tags. This removes all default directory scans and performs a custom scan using *only* the directories specified on the command line. For example:

	bake todo scan --dir bin --dir src --bug --fixme
	
* `--file`:

Add one or more files to the list of files to scan.

	bake todo scan --file bin/bake
	
If a file path starts with the pattern '(\.+)?/' then it will be treated as an absolute file path, otherwise the file is treated as relative to `${root}`.

## FLAGS

Flag options for task-todo(7).

* `--silent`:

Makes task-todo(7) mute, this is useful if you are only interested in the exit code.

## FILTER FLAGS

You may specify any tag as an option to switch on tag filtering, when any filter tag option is specified, then only the tags specified are matched. For example, to match only *BUG* tags, use:

	bake todo scan --bug
	
But to include any other tags they must now be specified, so to find *TODO* and *NOTE* tags, use:

	bake todo scan --todo --note

* `--bug`:

Filter for *BUG* tag matches.

* `--fixme`:

Filter for *FIXME* tag matches.

* `--todo`:

Filter for *TODO* tag matches.

* `--note`:

Filter for *NOTE* tag matches.

* `--xxx`:

Filter for *XXX* tag matches.

* `--changed`:

Filter for *CHANGED* tag matches.

* `--deprecated`:

Filter for *DEPRECATED* tag matches.

## TAGS

The following tags are supported by default:

* `BUG`:
	
To mark a known bug.

* `FIXME`:
	
To mark potential problematic code that requires special attention and/or review.

* `TODO`:
	
To indicate planned enhancements.

* `NOTE`:

To document inner workings of code and indicate potential pitfalls.

* `XXX`:

To warn other programmers of problematic or misguiding code.

* `CHANGED`:

To indicate that behaviour or implementation has changed.

* `DEPRECATED`:

To mark code as deprecated.

## EXIT CODES

If any *BUG* or *FIXME* tags are encountered then the program exits with a >0 exit code which is the total number of *BUG* and *FIXME* tags found, otherwise 0.

## DEPENDENCIES

find(1)

## BUGS

**task-todo** is written in bash and depends upon `bash` >= 4.

## COPYRIGHT

**task-todo** is copyright (c) 2012 muji <http://xpm.io>

## SEE ALSO

bake(1)
ronn:markdown

# map help for this task
help.man.page "todo" "task-todo.7";

# BUG : this is a test bug, no problem really
# TODO : this is a test todo, no problem really
# AFIX ME : this is a test fix me, no problem really
# FIXME : this is a test fixme, no problem really
# NOTE : this is a test note, no problem really

# TODO: reintegrate the ignore patterns with the file listing logic
declare -ag todo_ignore_patterns;
todo_ignore_patterns=(
	"\.log$"
	"\.tmp$"
	"\.bak$"
	"/\.git/?.*$"
	"\.gitignore$"
	"/target/?.*$"
	"/test/?.*$"
	"/man/?.*$"
	"/doc/?.*$"
	"/tmp/?.*$"
	"\.DS_Store$"
	"/package.json$"
	"/semver.json$"
	"/version$"
	"/tasks$"
	"/AUTHORS$"
	"/CHANGES$"
	"/LICENSE$"
	"/INSTALL$"
	"/README\.?.*$"
	"/Rakefile$"
);

declare -ag todo_dirs;
todo_dirs=(
	"bin"
	"lib"
	"src"
);

declare -Ag todo_tags;
todo_tags[fixme]="FIX ?ME[ 	,:]+[ 	]*(.*)";
todo_tags[bug]="BUG[ 	,:]+[ 	]*(.*)";
todo_tags[todo]="TODO[ 	,:]+[ 	]*(.*)";
todo_tags[note]="NOTE[ 	,:]+[ 	]*(.*)";
todo_tags[xxx]="XXX[ 	,:]+[ 	]*(.*)";
todo_tags[deprecated]="DEPRECATED[ 	,:]+[ 	]*(.*)";
todo_tags[changed]="CHANGED[ 	,:]+[ 	]*(.*)";

# tasks for working with todo tags
function tasks.todo {
	executable.validate find;	
	
	# list of files to scan
	declare -a files;
	files=();
	
	# custom list of dirs to scan
	# specified with --dir
	declare -a scandirs;
	scandirs=();	
	
	# custom list of files to scan
	# specified with --file
	declare -a scanfiles;
	scanfiles=();
	
	# custom tags to search for
	declare -a tags;
	tags=();
	
	# list of all tag keys
	# used internally
	declare -a all_tags;
	all_tags=( ${!todo_tags[@]} );	
	
	local include_symlinks=false;
	local silent=false;
	
	__todo.options.parse "$@";
	
	# custom tag filters
	if [ ${#tags[@]} -gt 0 ]; then
		local k;
		for k in ${!todo_tags[@]}
			do
				if ! array.contains? "$k" "${tags[@]}"; then
					unset todo_tags[$k];
				fi
		done
	fi
	
	# set up counters
	declare -A count;
	for k in ${all_tags[@]}
		do
			count[$k]=0;
	done
	
	# do command procesing via delegation
	if [ $# -gt 0 ]; then
		local method="td.${FUNCNAME}.${1}";
		if ! method.exists? "$method"; then
			console.quit 1 "invalid todo command %s" "$1";
		else
			delegate "td.${FUNCNAME}" "$1" ${@:2};
		fi
	else
		# no options specified scan files
		td.tasks.todo.scan;
	fi
}

# print tags
function td.tasks.todo.tags {
	local k p;
	for k in ${!todo_tags[@]}
		do
			p="${todo_tags[$k]}";
			k="${k^^}";
			__todo.log "$k=$p";
	done
	__todo.exit;
}

# print ignore patterns
function td.tasks.todo.excludes {
	local p
	for p in ${todo_ignore_patterns[@]}
		do
			__todo.log "$p";
	done
	__todo.exit;
}

# list matched files
function td.tasks.todo.list {
	__todo.log "# todo list ${root}";
	__todo.list;
	for f in ${files[@]}	
		do
			__todo.log "$f";
	done
	__todo.log "# ${#files[@]} files";
	__todo.exit;
}

# scan and gather tag information
function td.tasks.todo.scan {
	__todo.log "# todo scan %s" "${root}";
	__todo.list;
	for f in ${files[@]}
		do
			# echo "scanning file $f";
			__todo.scan.file "$f";
	done
	__todo.summary;
	__todo.exit;
}

# count tags
function td.tasks.todo.count {
	silent=true;
	__todo.list;
	for f in ${files[@]}
		do
			__todo.scan.file "$f";
	done
	__todo.count;
	__todo.exit;
}

######################################################################
#
#	PRIVATE METHODS
#
######################################################################

# parse options
function __todo.options.parse {
	
	# remove command option
	shift;
	
	# build up tag option comparison
	local tag_opts=();
	for k in ${all_tags[@]}
		do
			tags_opts+=( "--${k}" );
	done
	
	# handle custom tag filter flags
	local k;
	for k in ${!todo_tags[@]}
		do
			if array.contains? "--${k}" "$@"; then
				tags+=( "$k" );
			fi
	done
	
	# handle other options
	while [ "${1:-}" != "" ]; do
		if array.contains? "$1" "${tags_opts[@]}"; then
			shift;
			continue;
		fi
		case $1 in
			--silent )
				silent=true;
				;;				
			--file )
				shift;
				local file="${1:-}";
				if [ -z "$file" ]; then
					console.quit 1 "no file specified to %s" "--file";
				fi
				if [[ ! "$file" =~ ^(\.+)?/ ]]; then
					file="${root}/${file}";
				fi
				if [ ! -f "$file" ]; then
					console.warn "file %s is invalid" "$file";
				else
					fs.path.expand "$file";
					file="$_result";
					# add to custom list of files to scan
					scanfiles+=( "$file" );
				fi
				;;
			# TOOD: make this option resolve absolute file paths like the --file option
			--dir )
				shift;
				local dir="${1:-}";
				if [ -z "$dir" ]; then
					console.quit 1 "no directory specified to %s" "--dir";
				fi
				dir="${dir#/}";
				dir="${root}/${dir}";
				if [ -d "${dir}" ]; then
					scandirs+=( "$1" );
				else
 					console.warn "invalid scan directory %s" "$dir";
				fi
				;;
			* )
				console.warn "usage: todo [command] [options...]";
				console.quit 1 "unkown option %s" "$1";
				;;
		esac
		if [ $# -ne 0 ]; then
			shift;
		else
			break;
		fi
	done
}

function __todo.excludes? {
	local replace="${2:-}";
	local file="$1";
	if [ -n "$replace" ]; then
		# remove any trailing slash from the replacement
		replace="${replace/\$/}";
		file="${file#$replace}";
	fi
	
	# echo "testing exclude on $1 with ${#todo_ignore_patterns[@]}";
	local p;
	for p in ${todo_ignore_patterns[@]}
		do	
			# skip symbolic links
			if ! $include_symlinks && [ -L "$1" ]; then
				# echo "omitting symlink $1";
				return 0;				
			fi
			# skip on pattern match
			if [[ "$file" =~ $p ]]; then
				# echo "excluded : $file on $p";
				return 0;
			fi
	done
	return 1;
}

# use `find` to locate files to scan
function __todo.find {
	files+=( $( "${executables[find]}" "$1" -type f ) );
}

# build scan directories relative to ${root}
function __todo.find.dirs {
	local dir;
	for dir in $@
		do
			dir="${dir#/}";
			dir="${root}/${dir}";
			if [ -d "$dir" ]; then
				__todo.find "$dir";
			fi
	done
}

# get all files
function __todo.list {
	# default scan
	if [ ${#scanfiles} -eq 0 ] && [ ${#scandirs[@]} -eq 0 ]; then
		__todo.find.dirs "${todo_dirs[@]}";
	else
		if [ ${#scanfiles[@]} -gt 0 ]; then
			files+=( ${scanfiles[@]} );
		fi
		if [ ${#scandirs[@]} -gt 0 ]; then
			__todo.find.dirs ${scandirs[@]};
		fi
	fi
}

# test if a line matches a tag pattern
function __todo.line.matches? {
	local p;
	for tag in ${!todo_tags[@]}
		do	
			p="${todo_tags[$tag]}";
			if [ -n "$p" ]; then
				# echo "matching line with  $p : $line";
				if [[ "$line" =~ $p ]]; then
					todo="${BASH_REMATCH[1]:-}";
					frame="${file}:${lineno}";
					tag="${tag^^}";
					string.ltrim "$todo";
					todo="${_result}";			
					#__todo.output;
					return 0;
				fi
			fi
	done
	tag="";
	return 1;
}

# scan a file
function __todo.scan.file {
	# console.info "scanning %s" "$1";
	local file="$1";	
	local lineno=0;
	local tag frame todo;
	
	# linked list style to maintain order
	declare -a matchindex;
	declare -A filematches;
	__todo.scan.file.add()
	{
		local key="${tag}:${frame}";
		filematches["$key"]="${todo}";
		matchindex+=( "$key" );
	}
	
	while IFS= read -r line
		do	
			__todo.line;
	done < "$file";
	# process last line
	if [ -n "$line" ]; then __todo.line; fi
		
	# got some matches print them
	if [ ${#filematches[@]} -gt 0 ]; then
		__todo.print;
	fi
	
	# clean inner method definitions
	method.remove __todo.scan.file.add;
}

#print matches
function __todo.print {
	local k matches last_lineno=0;
	local len=$(( ${#filematches[@]} - 1 ));
	for k in ${matchindex[@]}
		do
			#echo "got key : $k";
			local IFS=":";
			matches=( $k );
			unset IFS;
			tag="${matches[0]}";	
			lineno="${matches[1]}";
			frame="${matches[2]}";
			# 
			todo="${filematches[$k]}";
			
			#echo "got todo: $todo"
		
			# if [ $i -lt $len ]; then
			# 	#echo "check for next match ... ";
			# fi
			echo "got match: $i : $tag : $lineno : $frame";
			
			last_lineno=$lineno;
	done
}

# process a line in the file
function __todo.line {
	: $((lineno++));	
	# test for tag matches
	if __todo.line.matches? "$line"; then
		# add the match
		#__todo.scan.file.add;
		
		__todo.output;
		
		# increment counters
		__todo.increment;
	fi
}

# log output
function __todo.log {
	if ! $silent; then
		console.log "$@";
	fi
}

function __todo.increment {
	local countkey="${tag,,}";
	: $(( count["$countkey"]++ ));	
}

# output todo tag information
function __todo.output {
	#echo "incrementing count on tag: $tag";
	if ! $silent; then
		if [ "$tag" == "BUG" ] || [ "$tag" == "FIXME" ]; then		
			echo "# $tag $frame" >&2;
			echo "$todo" >&2;
		else		
			console.log "# %s %s" "$tag" "$frame";
			console.log "$todo";
		fi
	fi
}

# print the count summary
function __todo.summary {
	if ! $silent; then
		string.repeat "+" 80;
		local header="$_result";	
		echo "$header";
		__todo.count;
		echo "$header";
	fi
}

function __todo.count {
	local k v;
	for k in ${!count[@]}
		do
			# tag filtering
			if [ ${#tags[@]} -gt 0 ] && ! array.contains? "$k" "${tags[@]}"; then
				continue;
			fi
			v="${count[$k]}";
			k="${k^^}";
			echo "$k=$v";
	done
}

#exit program
function __todo.exit {
	if [ ${#count[bug]} -gt 0 ] || [ ${#count[fixme]} -gt 0 ]; then
		local total=$(( ${count[bug]} + ${count[fixme]} ));
		console.quit $total;
	else
		console.quit 0;
	fi
}